<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LUMIMA - 虚空视界</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@800&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        #ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            text-align: center;
            color: #ffffff;
            pointer-events: none;
            z-index: 10;
            width: 100%;
            mix-blend-mode: screen; 
        }

        h1.main-title {
            margin: 0;
            font-family: 'Montserrat', sans-serif;
            font-size: 100px;
            font-weight: 800;
            letter-spacing: 15px;
            color: #fff;
            opacity: 0;
            /* 稍微调整动画，让它更平稳 */
            animation: 
                fadeInUp 2.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards, 
                glowBreathe 6s ease-in-out infinite 2.5s; 
        }

        @keyframes fadeInUp {
            0% { opacity: 0; transform: translateY(30px) scale(0.95); filter: blur(10px); }
            100% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
        }

        @keyframes glowBreathe {
            0%, 100% { text-shadow: 0 0 15px rgba(255, 255, 255, 0.6), 0 0 30px rgba(255, 255, 255, 0.3); }
            50% { text-shadow: 0 0 25px rgba(255, 255, 255, 0.9), 0 0 50px rgba(255, 255, 255, 0.6), 0 0 90px rgba(200, 220, 255, 0.3); }
        }

        .controls-hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 11px;
            letter-spacing: 2px;
            pointer-events: none;
            z-index: 10;
            text-transform: uppercase;
            animation: fadeIn 3s ease-out 1s forwards;
            opacity: 0;
        }

        @keyframes fadeIn { to { opacity: 1; } }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        <h1 class="main-title">LUMIMA</h1>
    </div>
    
    <div id="canvas-container"></div>
    <div class="controls-hint">Drag to Orbit &bull; Scroll to Zoom</div>

    <script type="x-shader/x-vertex" id="vertexShader">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = vec4(position, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        uniform float iTime;
        uniform vec2 iResolution;
        uniform vec3 iCamPos;
        uniform vec3 iCamTarget;
        
        varying vec2 vUv;

        #define MAX_STEPS 100
        #define MAX_DIST 60.0
        #define BH_RADIUS 1.5
        #define DISK_INNER 2.2
        #define DISK_OUTER 5.8
        
        // --- 基础噪声函数 (保留给吸积盘使用) ---
        float hash(float n) { return fract(sin(n) * 43758.5453123); }
        float noise(vec3 x) {
            vec3 p = floor(x);
            vec3 f = fract(x);
            f = f * f * (3.0 - 2.0 * f);
            float n = p.x + p.y * 57.0 + 113.0 * p.z;
            return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                           mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
                       mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                           mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
        }

        // --- FBM (仅用于吸积盘纹理) ---
        float fbm(vec3 p) {
            float f = 0.0;
            float amp = 0.5;
            for(int i=0; i<5; i++) {
                f += amp * noise(p);
                p *= 2.0;
                amp *= 0.5;
            }
            return f;
        }

        // --- 核心渲染 ---
        vec3 render(vec3 ro, vec3 rd) {
            vec3 col = vec3(0.0); // 背景默认为纯黑
            vec3 p = ro;
            vec3 v = rd;
            
            float diskAcc = 0.0;
            vec3 diskCol = vec3(0.0);
            
            float distToCenter = 0.0;
            float totDist = 0.0;
            
            // Raymarching 循环
            for(int i = 0; i < MAX_STEPS; i++) {
                distToCenter = length(p);
                
                // 1. 引力弯曲模拟
                // 在强引力场中，光线会弯曲。
                // 我们不模拟完整的广义相对论度规，而是用一个简化的牛顿近似力来偏转光线方向。
                float gravityStrength = 0.15 * (1.0 / (distToCenter * distToCenter + 0.1));
                vec3 toCenter = normalize(-p);
                v = normalize(v + toCenter * gravityStrength); 
                
                // 2. 光子推进一步
                // 距离黑洞越近，步长越小，以获得高精度渲染
                float stepSize = max(0.1, distToCenter * 0.08); 
                p += v * stepSize;
                totDist += stepSize;
                
                // 3. 事件视界检测 (Event Horizon)
                if(distToCenter < BH_RADIUS) {
                    // 光线落入黑洞，不再返回。
                    // 直接返回目前为止累积的吸积盘颜色（如果有的话）。
                    // 背景部分保持为黑色 (col 为 0.0)
                    return diskCol;
                }
                
                // 4. 吸积盘渲染 (Accretion Disk)
                float absY = abs(p.y);
                // 只在赤道平面附近计算
                if(absY < 0.6) { 
                    float d = length(p.xz); // 径向距离
                    
                    // 检查是否在盘的半径范围内
                    if(d > DISK_INNER && d < DISK_OUTER) {
                        float angle = atan(p.z, p.x);
                        
                        // 开普勒旋转速度：越近越快
                        float speed = 3.0 / (d - 0.5); 
                        float timeOffset = iTime * speed;
                        
                        // 生成流动的等离子体纹理
                        vec3 noisePos = vec3(p.x * 2.5, p.z * 2.5, timeOffset);
                        float noiseVal = fbm(noisePos);
                        
                        // 边缘淡入淡出
                        float radialFade = smoothstep(DISK_INNER, DISK_INNER + 0.8, d) * (1.0 - smoothstep(DISK_OUTER - 1.5, DISK_OUTER, d));
                        // 垂直厚度衰减
                        float verticalFade = exp(-absY * 12.0);
                        
                        float intensity = noiseVal * radialFade * verticalFade;
                        
                        // 颜色：核心亮白，边缘橙金
                        vec3 sampleColor = mix(vec3(0.8, 0.3, 0.05), vec3(1.0, 0.8, 0.5), intensity * 2.0);
                        
                        // 相对论多普勒效应 (Beaming)
                        // 朝向观察者移动的一侧更亮，远离的一侧更暗
                        vec3 tanDir = normalize(vec3(-p.z, 0.0, p.x));
                        float doppler = dot(tanDir, normalize(ro));
                        intensity *= (1.0 + doppler * 0.6); 

                        // 累积颜色 (Alpha Blending)
                        float alpha = intensity * stepSize * 2.5;
                        alpha = clamp(alpha, 0.0, 1.0);
                        
                        diskCol += sampleColor * alpha * (1.0 - diskAcc);
                        diskAcc += alpha;
                        
                        // 如果光线完全被吸积盘遮挡，就不需要继续计算了
                        if(diskAcc >= 1.0) break;
                    }
                }
                
                // 超出最大渲染距离，认为进入深空
                if(totDist > MAX_DIST) break;
            }
            
            // 这里不再添加任何星星背景 (col 保持为 0.0)
            
            return diskCol + col;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
            vec3 ro = iCamPos;
            vec3 ta = iCamTarget;
            
            // 构建相机矩阵
            vec3 ww = normalize(ta - ro);
            vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));
            vec3 vv = normalize(cross(uu, ww));
            float fov = 1.3; 
            vec3 rd = normalize(uv.x * uu + uv.y * vv + fov * ww);
            
            // 渲染场景
            vec3 col = render(ro, rd);
            
            // 后期处理
            // Gamma 校正
            col = pow(col, vec3(0.6)); 
            // 增加对比度，确保黑色背景纯净
            col = smoothstep(0.02, 1.0, col);

            // 晕影效果 (Vignette) - 让角落更暗，聚焦中心
            float vignette = 1.0 - smoothstep(0.5, 1.6, length(uv));
            col *= mix(0.6, 1.0, vignette);

            // 全局亮度调整 (保持您之前的暗调要求)
            col *= 0.5;

            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script>
        const container = document.getElementById('canvas-container');
        const uiTitle = document.querySelector('#ui');
        
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        let mouseX = 0, mouseY = 0;
        let targetLat = 0, targetLon = 0;
        let lat = 0, lon = -1.5;
        let distance = 11.0;
        let isDragging = false;
        let lastX, lastY;
        let parallaxX = 0, parallaxY = 0;

        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            iCamPos: { value: new THREE.Vector3() },
            iCamTarget: { value: new THREE.Vector3(0, 0, 0) }
        };

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: uniforms
        });

        scene.add(new THREE.Mesh(geometry, material));

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
        });

        container.addEventListener('mousedown', e => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            container.style.cursor = 'grabbing';
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            container.style.cursor = 'default';
        });

        window.addEventListener('mousemove', e => {
            if (isDragging) {
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                targetLon -= dx * 0.005;
                targetLat += dy * 0.005;
                targetLat = Math.max(-1.4, Math.min(1.4, targetLat));
                lastX = e.clientX;
                lastY = e.clientY;
            }

            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const pFactor = 0.03; 
            const targetPX = (e.clientX - centerX) * pFactor;
            const targetPY = (e.clientY - centerY) * pFactor;
            parallaxX += (targetPX - parallaxX) * 0.1;
            parallaxY += (targetPY - parallaxY) * 0.1;
            uiTitle.style.transform = `translate(calc(-50% - ${parallaxX}px), calc(-50% - ${parallaxY}px))`;
        });

        container.addEventListener('wheel', e => {
            distance += e.deltaY * 0.01;
            distance = Math.max(5.0, Math.min(20.0, distance));
        });
        
        container.addEventListener('touchstart', e => {
            isDragging = true;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        }, {passive: false});

        container.addEventListener('touchmove', e => {
            if (isDragging) {
                e.preventDefault();
                const dx = e.touches[0].clientX - lastX;
                const dy = e.touches[0].clientY - lastY;
                targetLon -= dx * 0.005;
                targetLat += dy * 0.005;
                targetLat = Math.max(-1.4, Math.min(1.4, targetLat));
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            }
        }, {passive: false});
        
        window.addEventListener('touchend', () => isDragging = false);

        function animate(time) {
            requestAnimationFrame(animate);
            uniforms.iTime.value = time * 0.001;
            lat += (targetLat - lat) * 0.05;
            lon += (targetLon - lon) * 0.05;
            const cx = distance * Math.cos(lat) * Math.sin(lon);
            const cy = distance * Math.sin(lat);
            const cz = distance * Math.cos(lat) * Math.cos(lon);
            uniforms.iCamPos.value.set(cx, cy, cz);
            renderer.render(scene, camera);
        }

        animate(0);
    </script>
</body>
</html>